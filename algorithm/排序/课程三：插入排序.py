# alist=[93     ，54，77，31，44，55，226]
# alist=[54，93   ，77，31，44，55，226]
# alist=[54,77,93     ，31,44,55,226]
# 分为有序和无序序列
# 先将第一个值固定，后续拿一个值与第一个值对比，排序插入
# 此时再将 后续拿一个值 与刚形成的有序序列对比，排序插入
# 从无序序列中拿出一个值，与有序序列对比，看插入哪个位置


def insert_sort(alist):
    '''插入排序'''
    n = len(alist)
    # 从右边的无序序列中取出多少个元素执行这样的过程
    for j in range(1, n):
        # i =[1,2,3,....,n-1]
        # i 代表内层循环起始值
        i = j
        # 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面的正确位置中
        while i > 0:
            if alist[i] < alist[i - 1]:
                alist[i], alist[i - 1] = alist[i - 1], alist[i]
                i -= 1
            # 这里的i取值 j j-1 j-2 ....1
            # 即 range(j,0,-1)
            else:
                break
                # 该处为优化，当现在的值小于前一个值，则结束，不再去对比更前面的值
    return alist


if __name__ == '__main__':
    alist = [93, 54, 77, 31, 44, 55, 226]
    print(insert_sort(alist))
# 最坏时间复杂度O（n^2）
# 最优时间复杂度O（n）
# 稳定


'''
 插入排序的核心在于，它把一个无序数列看成两个数列，假如第一个元素构成了第一个数列，那么余下
 的元素构成了第二个数列，很显然，第一个数列是有序的（因为只有一个元素嘛，肯定有序哦），那么
 我们把第二个数列的第一个元素拿出来插入到第一个数列，使它依然构成一个有序数列，直到第二个数
 列中的所有元素全部插入到第一个数列，这时候就排好序了。

      插入排序的复杂度是O(n^2)，在数据量较小时效率较高。
'''
