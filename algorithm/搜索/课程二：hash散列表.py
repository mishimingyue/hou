# 散列表其实就是数组的一种扩展
# 思想：例如在,只给N个数，1<N<100,判断50，1，5，6，15这些数是否在N当中
# 设置一个初始数组，将所有值都置为0，通过下标进行一一映射，
# 例如将a=[] a[50]=1,a[1]=1,a[5]=1,a[6]=1,a[15]=1，那么我只需要通过下标，去判断值是0还是1就可以知道是否存在这个数
# 时间复杂度是O(1)

# 散列函数：Hash函数

# 例如： N：10（N的范围在1到1亿中）
# 10，20，14，52，63 判断30在不在；   因为1亿不可能花一亿的存储空间去制造
# 思路： 首先取余   a[10%10]=a[0]=10  a[14%10]=a[4]=14  a[63%10]=a[3]=63
# 30%10=0   ；  若a[20%10]=a[0] ，则发生了hash冲突
# 两种方式解决hash冲突：探测（线性寻址，开放寻址），链表

# 探测：发生hash碰撞时，按顺序往下寻找没有数据的位置，存储进去；
# 当去寻址时，例如a[10],a[20]，hash函数都是对10进行取余，寻找20，一开始找到a[0]时，发现位置并非10，则继续往下寻找，遇到有数据和delete继续往下寻找，直到找到空数据停止
# 存在缺点：（1）装不下：进行扩容  （2）全部hash碰撞，则变成一条线性数据  （3）删除：删除数据则会给数据标记上Delete

# 链表，找到a[0]对应的链表，同一a[0]后可以根据链表的节点地址去衔接查找
# 优点：插入删除快，使用简单  缺点：遍历慢
